# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# appdeploy values.yaml defaults
#   - Required items are marked as such
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# At a minimum you need to provide these 3 variables
app:
  name: ""         # required
  environment: ""  # required
  context: ""      # required

  # and ...optionally "classifier" default nothing. Typically used for
  # apps that expose multiple ports where only certain port(s)
  # are relevant for the app depending on what "classifier" it is
  # Services/Ingresses are not generated for ports that do not match
  # this classifier value if it is not empty
  #
  # See containerPorts.[classifiers]
  classifier: ""

  # REQUIRED: defaults to app.name, but you should tweak it if you run into
  # k8s length errors. tpl variable substitution supported here. See README
  #
  # shortName is used for all k8s version specific object name generation
  # as well as ingress' by default. You MUST SET SHORT NAME!
  #
  shortName: "{{ .Values.app.name }}"



# Basic Deployment image properties that are REQUIRED to be set
image:
  repository: "" # Required
  tag: ""        # Required
  pullPolicy: IfNotPresent


# The label "names" (i.e. keys) for common labels
# that will be applied to all created k8s objects
labelNames:
  appName: "app-name"
  appShortName: "app-shortname"
  appContext: "app-context"
  appEnvironment: "app-environment"
  appVersion: "app-version"
  appClassifier: "app-classifier"
  creatorId: "app-creator-id"
  hashId: "app-hash-id"


# tpl variable substitution supported here. See README
env:
  #ENV_VAR_1:
  # value: "something" # PARSED by Helm 'tpl' function passed $
  #ENV_VAR_2:
  # value: "something"

# the configMaps and/or secrets to mount env vars from
# only valid envFrom references are configMapRef and secretRef
# but you can have multiples of each
envFrom: []
  # - secretRef:
  #     name: "env-secret-name"
  # - configMapRef:
  #     name: "env-configmap-name"


# The number of replicas for the generated Deployment
replicaCount: 1


# The user installing/upgrading the chart
# this will be decorated on every object as
# an additional label
creatorId: "unknown@bitsofinfo.appdeploy.chart"


# The k8s ServiceAccount pods will run as
# this is NOT the uid:gid the process rus as (see securityContext)
serviceAccount:
  name: "default" # tpl variable substitution supported here. See README, PARSED by Helm 'tpl' function passed $
  create: false

  # If create is TRUE; If you MUST define the following items
  # this will create the ServiceAccount, [Cluster]Role, [Cluster]RoleBinding
  #kind: ClusterRole|Role
  #namespace: "[[#namespace]]"
  #apiGroups: [""]  # "" indicates the core API group
  #resources: []
  #verbs: []

# Options to customize the securityContext of Pods in the Deployment
securityContext:
  allowPrivilegeEscalation: false
  #runAsUser: 9999
  #runAsGroup: 9999
  #fsGroup: 9999

# Optional: The k8s secret name to be used if the Deployment object
# needs to pull images (i.e. if your image.repository is custom)
# should be an array of k8s secret names (strings)
imagePullSecrets: []

# You should list at least ONE containerPort
containerPorts:
  # Each containerPort has various options
  #- port: 9000
  #  name: apache-https
  #  ingress: true  # if an Ingress should be generated for this port
  #  service: true  # if an Service should be generated for this port
  #  tls: true      # if the port exposes TLS
  #  classifiers: ["something"]   # this is an optional property


# optional aliases. Each alias will be used to generate
# an additional version specific ingress FQDN in addition to the
# standard one from app.name
aliases: []


# Optional: specify the Pod restart policy
restartPolicy: Always


# Pod customization
pod:
  # tpl variable substitution supported in values here. See README
  labels: []
  #  - name: "label-name"
  #    value: "label value" # PARSED by Helm 'tpl' function passed $

  annotations: []
  #  - name: "annotation-name"
  #    value: "annotation value" # PARSED by Helm 'tpl' function passed $

  # Optional hostname/subdomain k8s dns related attrs for the spec
  # tpl variable substitution supported in values here. See README
  # https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
  #hostname:
  #subdomain:

# Options to customize the generated version specific Service
# This is always generated and is a dedicated service object
# with version specific selectors pointing to pods in the
# deployment.
service:
  type: ClusterIP

  # tpl variable substitution supported in values here. See README
  # Note these are "extra" labels in addition to auto-generated standard
  # labels that are applied to all chart objects
  labels: []
  #  - name: "label-name"
  #    value: "label value" # PARSED by Helm 'tpl' function passed $


# Optional "extra service" that can be generated that will target
# the pods generated by this chart. Here you can provide a custom
# name, labels, selectors and customize the type which permits
# a non-k8s standard type value option of "Headless" which will
# set "spec.clusterIP: None"; see:
# https://kubernetes.io/docs/concepts/services-networking/service/#headless-services
#
# This is here if you want to specify and maintain a a well known
# service w/ completely custom selectors + name etc.
#
extraService:
  enabled: false # toggle to enable, default off

  # name is a tpl parsed val, PARSED by Helm 'tpl' function passed $
  name: "{{ .Values.app.name }}-{{ .Values.app.context }}"

  # (valid values Headless, ClusterIP, NodePort, LoadBalancer)
  # if "Headless" will auto set: spec.clusterIP: None
  type: Headless

  # tpl variable substitution supported in values here. See README
  # Note these are "extra" labels in addition to auto-generated standard
  # labels that are applied to all chart objects
  labels: []
  #  - name: "label-name" # PARSED by Helm 'tpl' function passed $
  #    value: "label value" # PARSED by Helm 'tpl' function passed $

  # tpl variable substitution supported in values here. See README
  annotations:
    #"annotation/name1": "something" # PARSED by Helm 'tpl' function passed $
    #annotationName2: "something" # PARSED by Helm 'tpl' function passed $

  # tpl variable substitution supported in values here. See README
  selectors:
    - name: "{{ .Values.labelNames.appName }}"   # PARSED by Helm 'tpl' function passed $
      value: "{{ .Values.app.name }}"      # PARSED by Helm 'tpl' function passed $
    - name: "{{ .Values.labelNames.appContext }}"   # PARSED by Helm 'tpl' function passed $
      value: "{{ .Values.app.context }}"      # PARSED by Helm 'tpl' function passed $


# Options to customize the generated version specific Ingresses (one per port)
# NOTE! if you want to deploy your own "isolated" version specific app instance
# that does not collide with any others, simply tweak the fqdnSuffix. You can
# also optionally declare the fqdnSuffixPrefix to acheive a similar result but
# with a different level of configurability which gives different options if you
# are using this with higher level tooling where values decoration might vary based
# on target cluster being deployed for instance.
#
# given a "fullAppIdentifier" that gets generated as:
#      appName-context-version-classifier
#
# required:
#   ingress.dns.fqdnSuffix="-x.local"
#     would yield: appName-context-version-classifier-x.local
#
# optional:
#   ingress.dns.fqdnSuffixPrefix="-something"
#     would yield: appName-context-version-classifier-something-x.local
#
ingress:
  k8sApiVersion: "networking.k8s.io/v1beta1"

  # should only be set to something on k8s 1.18+
  # leaving as a blank string "" will not emit it
  # into the ingress object
  pathType: ""

  # name of annotation key that tells the ingress controller
  # if backend is http or https
  backendProtocolAnnotationKey: "ingress.kubernetes.io/protocol"

  # the ingressClassName required for networking.k8s.io/v1
  # otherwise defaults to nothing (empty string), won't be applied
  # this CANNOT co-exist w/ annotation "kubernetes.io/ingress.class"
  # only available in k8s 1.18+
  ingressClassName: ""

  dns:
    fqdnSuffix: ".local"
    fqdnSuffixPrefix: "" # default nothing, this is pre-pended to the fqdnSuffix
  tls:
    enabled: false
    secretName: "" # you need to set this!
  metadata:
    # tpl variable substitution supported in values here. See README
    labels:
      #"label/name1": "something" # PARSED by Helm 'tpl' function passed $
      #labelName2: "something" # PARSED by Helm 'tpl' function passed $
    annotations:
      #"annotation/name1": "something" # PARSED by Helm 'tpl' function passed $
      #annotationName2: "something" # PARSED by Helm 'tpl' function passed $

# Options to customize the bootstrapSecret secret/mount details
# This is optional via the flag "enabled"
bootstrapSecret:
  enabled: false
  k8Secret:
    valueKey: "bootstrap_secret"
    secretValue: ""  # REQUIRED! you must provide this if enabled
  mount:
    defaultMode: 256 # 0400
    path: "/opt/secrets"
    fileName: "bootstrap-secret"

# Resources customization
# https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
resources:
  limits:
#    cpu: "1" # example only
#    memory: "500Mi" # example only
  requests:
#    cpu: ".25" # example only
#    memory: "250Mi" # example only


# Horizontal Pod Autoscaler
# https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
# This is optional via the flag "enabled"
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 2
  # if enabled, you need to set at least one of the below options
  #targetCPUUtilizationPercentage: 75  # example only
  #targetMemoryUtilizationPercentage: 75  # example only


# Pod Disruption Budget
# https://kubernetes.io/docs/tasks/run-application/configure-pdb/#specifying-a-poddisruptionbudget
# This is optional via the flag "enabled"
disruptionBudget:
  enabled: false
  # if enabled, you need to set EITHER maxUnavailable OR minAvailable.  NOT BOTH!!
  # can be an absolute number OR percentage
  #maxUnavailable: "25%"  # example only
  #minAvailable: 2  # example only


# Healthcheck customization
# YOU must provide containerPort for each one
healthcheck:
  liveness:
    scheme: "HTTPS"
    #containerPort:    # Required
    path: "/health"
    disabled: "false"
    initialDelaySeconds: 120
    periodSeconds: 15
    timeoutSeconds: 5
    failureThreshold: 3
  readiness:
    scheme: "HTTPS"
    #containerPort:   # Required
    path: "/health"
    disabled: "false"
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 3
    failureThreshold: 1


# Optional but your chart should provide these
# tpl variable substitution supported here. See README
command:
  #command: ["java"] # optional

  #preArgs: (optional)
  # -"preArg1"  # PARSED by Helm 'tpl' function passed $

  #args:
  # -"arg1"  # PARSED by Helm 'tpl' function passed $

  #postArgs: (optional)
  # -"postArg1"  # PARSED by Helm 'tpl' function passed $



# Customization of post-deploy, pre-delete helm hooks
# @see https://github.com/bitsofinfo/kubernetes-helm-healthcheck-hook
# NOTE you may want to adjust your helm client timeouts
# accordingly to wait for these
#
# There are two subsections here
# * "default": standard appdeploy hooks
# * "custom": custom hooks you can define, default none (see below for docs)
#
hooks:

  # Default chart Jobs:
  #
  # These are default chart hooks that ship w/ the chart out of the box
  # you can disable/enable them as you wish
  default:

    # Default chart Hooks to be executed POST on upgrade/install
    postInstallUpgrade:

      # After install/upgrade we auto-check /health by default
      # and then alert on the results.
      validator:
        enabled: true
        # if false, will use k8s service name
        # [fullAppIdentifier].[.Release.Namespace].svc.cluster.local:[port] and NOT go via Ingress
        useIngressHost: true
        image: "bitsofinfo/kubernetes-helm-healthcheck-hook:0.1.19"
        maxRetries: 60
        sleepSeconds: 30
        hookDeletePolicy: hook-succeeded,before-hook-creation
        debugOutput: false # enables very verbose logging of all result objects to aid in debugging
        debugRequests: false # enables very verbose request/response logging to aid in debugging
        checksConfig:
          - name: "/health check"
            path: "/health"
            method: "GET"
            timeout: 5
            retries: 30
            tags: ["80","443"]
        slackConfig:
          postDeploy:
            name: "post-deploy"
            webhook_url: https://hooks.slack.com/services/YOU/NEED/TO/PROVIDE
            template: >
              {
                "text":"*Deployed:* {{ check_name }} *{{ 'OK' if overall_result else 'FAILED' }}* ",
                "attachments": [
                    {
                      "color": "{{ 'good' if overall_result else 'danger' }}",
                      "fields": [
                        {
                          "value":"{{ check_name }} has been deployed by *{{ extra_props.creatorId }}*. {{ 'All checks below are *OK*' if overall_result else 'One or more checks below *FAILED*' }}"
                        }
                      ]
                    }

                    {% for check in checks %}
                      ,{
                        "color": "{{ 'good' if check.result.success else 'danger' }}",
                        "fields": [
                          {
                            "value":"{{ check.method }} *{{ check.path }}* *{{ 'SUCCEEDED' if check.result.success else 'FAILED' }}* with *{{ check.result.code }}*. {% if not check.result.success %}*reason:* {{ check.result.error }}{% endif %}"
                          }
                        ]
                      }
                  {% endfor %}
                ]
              }


    # Default chart Hooks to be executed POST on delete
    postDelete:

      # After helm delete we validate that a 404 is returned
      # for / for the generated ingress (i.e. it should be gone!)
      validator:
        enabled: true
        # if false, will use k8s service name
        # [fullAppIdentifier].[.Release.Namespace].svc.cluster.local:[port] and NOT go via Ingress
        useIngressHost: true
        image: "bitsofinfo/kubernetes-helm-healthcheck-hook:0.1.19"
        maxRetries: 60
        sleepSeconds: 30
        hookDeletePolicy: hook-succeeded,before-hook-creation
        debugOutput: false # enables very verbose logging of all result objects to aid in debugging
        debugRequests: false # enables very verbose request/response logging to aid in debugging
        checksConfig:
          - name: "/ post delete check"
            path: "/"
            method: "GET"
            is_healthy:
              # DNS issues also affirmative of it being deleted (if auto-dns removes name)
              error_msg_reasons: ["Name does not resolve"]
            is_not_healthy:
              # anything OTHER than 200 is healthy.. (i.e. app does not exist)
              response_codes: [200]
            timeout: 5
            retries: 30
        slackConfig:
          postDelete:
            name: "post-delete"
            webhook_url: https://hooks.slack.com/services/YOU/NEED/TO/PROVIDE
            template: >
              {
                "text":"*Removed:* {{ check_name }} *{{ 'OK' if overall_result else 'FAILED' }}* ",
                "attachments": [
                    {
                      "color": "{{ 'good' if overall_result else 'danger' }}",
                      "fields": [
                        {
                          "value":"{{ check_name }} has been removed by *{{ extra_props.creatorId }}*."
                        }
                      ]
                    }
                ]
              }

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Optional: You can define one or more custom hooks which will be created
  # as k8s Jobs each additional top level key under "custom" will yield
  # an additional Job
  #
  # See examples/example.yaml for a working sample
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #custom:

    # the Hook Job name
    #example:

      # enabled true/false
      #enabled: false

      # Optional: variables:
      #
      # This is an optional structure you can use for being able to
      # define custom values in a structured fashion that are more easily
      # addressible via `--set` that can then be referenced via as "tpl"
      # parsed vars in harder to customize yaml list sections such as "labels"
      # "env" and "args" farther below.
      #variables:
        # You can define any structure, nested or non-nested here
        #test:
        #  dummy1: "dummy1val"
        #  dummy2: "dummy2val"

      # Helm hook related options
      #hook:
        # the value for the helm.sh/hook annotation
        #type: pre-install,pre-upgrade
        # the value for the helm.sh/hook-weight annotation
        #weight: 0
        # the value for the helm.sh/hook-delete-policy annotation
        #deletePolicy: before-hook-creation

      # Options for the Job that will be created
      #job:
        #backoffLimit: 0 # number of retries
        #activeDeadlineSeconds: 300

      #------------------------------------------------------
      # The structure of the remaining options are the same as those
      # documented at the root level of this values.yaml file
      # and they are used to control the Job.spec.template for
      # the Pod that will be created for the Job
      #------------------------------------------------------

      #image:
      #  repository: "" # Required
      #  tag: "" # Required

      # Pod customization
      #pod:
        # tpl variable substitution supported in values here. See README
        #labels: []

      #restartPolicy: Never

      #imagePullSecrets: []

      #serviceAccount:
      #  name: "default"
      #  create: false # currently, not supported yet for Jobs. Setting true will do nothing

      # tpl variable substitution supported here. See README
      # each ENV var "value" will be PARSED by the Helm 'tpl' function
      # You can reference ANY values.yaml var navigable via $
      #env:
        #ENV_VAR_1:
        # value: "something {{.Values.app.name}}" # PARSED by Helm 'tpl' function passed $
        #ENV_VAR_2:
        # value: "{{.Values.hooks.custom.example.variables.test.dummy1}}"

      # Optional but your chart should provide these
      # tpl variable substitution supported here. See README
      #command:
        #command: ["java"] # optional

        #preArgs: (optional)
        # -"preArg1"  # PARSED by Helm 'tpl' function passed $

        #args:
        # -"{{.Values.hooks.custom.example.variables.test.dummy2}}"  # PARSED by Helm 'tpl' function passed $

        #postArgs: (optional)
        # -"postArg1"  # PARSED by Helm 'tpl' function passed $

      # Options to customize the Job's bootstrapSecret secret/mount details
      # This is optional via the flag "enabled"
      # Note the bootstrapSecret.k8Secret.secretValue below is 'tpl' parsed
      # so you can reference the top level secret if you'd like to re-use it:
      # i.e secretValue: "{{.Values.bootstrapSecret.k8Secret.secretValue}}"
      #
      # IF enabled, a dynamic variable will be created under:
      #   .Values.hooks.custom.[thishook].variables.hookBootstrapSecretFilePath
      #
      # Who's value is set = {{[thishook].bootstrapSecret.mount.path/[thishook].bootstrapSecret.mount.fileName}}
      #
      #bootstrapSecret:
      #  enabled: false
      #  k8Secret:
      #    valueKey: "bootstrap_secret"
      #    secretValue: "{{.Values.bootstrapSecret.k8Secret.secretValue}}"  # (tpl parsed) REQUIRED! you must provide this if enabled
      #  mount:
      #    defaultMode: 256 # 0400
      #    path: "/opt/secrets"
      #    fileName: "bootstrap-secret"
